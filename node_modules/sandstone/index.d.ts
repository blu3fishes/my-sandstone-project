export declare const savePack: (name: string, options: import("./datapack/saveDatapack").SaveOptions) => Promise<{
    destination: string | null;
}>, BasePath: <N extends string | undefined, D extends string | undefined>(basePath: import("./datapack/BasePath").BasePathOptions<N, D>) => import("./datapack/BasePath").BasePathInstance<N, D>, sleep: (delay: import("./arguments").TimeArgument) => PromiseLike<void>;
export declare const MCFunction: <RETURN extends void | Promise<void>>(name: string, callback: () => RETURN, options?: import("./resources").MCFunctionOptions | undefined) => import("./datapack/Datapack").MCFunctionInstance<RETURN>, Advancement: <T extends string>(name: string, advancement: import("./arguments").AdvancementJSON<T>, options?: import("./resources").AdvancementOptions | undefined) => import("./resources").AdvancementInstance<T>, Predicate: (name: string, predicate: import("./arguments").PredicateJSON, options?: import("./resources").PredicateOptions | undefined) => import("./resources").PredicateInstance, Tag: <T extends import("./arguments").TAG_TYPES>(type: T, name: string, values?: import("./arguments").TagSingleValue<import("./arguments").HintedTagStringType<T>>[], replace?: boolean | undefined, options?: import("./resources").TagOptions | undefined) => import("./resources").TagInstance<T>, LootTable: (name: string, lootTable: import("./arguments").LootTableJSON, options?: import("./resources").LootTableOptions | undefined) => import("./resources").LootTableInstance, Recipe: <P1 extends string, P2 extends string, P3 extends string>(name: string, recipe: import("./arguments").RecipeJSON<P1, P2, P3>, options?: import("./resources").RecipeOptions | undefined) => import("./resources").RecipeInstance<P1, P2, P3>;
export { _ } from './init';
export * from './commandsOnly';
export { absolute as abs, local as loc, relative as rel, } from './variables';
export * from './variables/Coordinates';
export * from './variables/JSONTextComponentClass';
export * from './variables/NBTs';
export * from './variables/Objective';
export * from './variables/parsers';
export * from './variables/Score';
export { SelectorClass } from './variables/Selector';
export declare const Objective: {
    create: (name: string, criteria?: import("./generalTypes").LiteralUnion<import("./arguments").OBJECTIVE_CRITERION>, display?: import("./arguments").JSONTextComponent | undefined) => import("./init").ObjectiveInstance<string | undefined>;
    get: (name: string) => import("./init").ObjectiveInstance<string | undefined>;
}, Selector: import("./init").SelectorCreator, Data: <TYPE extends import("./variables/Data").DATA_TYPES, TARGET extends import("./variables/Data").DATA_TARGET[TYPE] | undefined = undefined>(type: TYPE, target?: TARGET | undefined) => TARGET extends undefined ? import("./variables/Data").TargetlessDataInstance<import("./variables/Data").DATA_TYPES> : import("./variables/Data").DataInstance<import("./variables/Data").DATA_TYPES>, Variable: ((initialValue?: number | import("./variables/Score").Score<string | undefined> | undefined, name?: string | undefined) => import("./variables/Score").Score<string | undefined>) & ((nbt: import("./variables/Data").DataPointInstance<import("./variables/Data").DATA_TYPES>, scale?: number | undefined, name?: string | undefined) => import("./variables/Score").Score<string | undefined>);
export * from './arguments';
export * from './datapack/BasePath';
export * from './datapack/Datapack';
export type { LiteralUnion } from './generalTypes';
export type { AdvancementInstance, LootTableInstance, MCFunctionOptions, PredicateInstance, RecipeInstance, ResourceInstance, TagInstance, } from './resources';
